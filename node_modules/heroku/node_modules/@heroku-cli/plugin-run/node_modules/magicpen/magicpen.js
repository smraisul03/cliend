/*!
 * Copyright (c) 2014 Sune Simonsen <sune@we-knowhow.dk>
 * 
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the 'Software'), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var o;"undefined"!=typeof window?o=window:"undefined"!=typeof global?o=global:"undefined"!=typeof self&&(o=self),(o.weknowhow||(o.weknowhow={})).MagicPen=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var utils = require(11);
var TextSerializer = require(5);
var colorDiff = require(16);
var rgbRegexp = require(9);
var themeMapper = require(10);

var cacheSize = 0;
var maxColorCacheSize = 1024;

var ansiStyles = utils.extend({}, require(12));
Object.keys(ansiStyles).forEach(function (styleName) {
    ansiStyles[styleName.toLowerCase()] = ansiStyles[styleName];
});

function AnsiSerializer(theme) {
    this.theme = theme;
}

AnsiSerializer.prototype = new TextSerializer();

AnsiSerializer.prototype.format = 'ansi';

var colorPalettes = {
    16: {
        '#000000': 'black',
        '#ff0000': 'red',
        '#00ff00': 'green',
        '#ffff00': 'yellow',
        '#0000ff': 'blue',
        '#ff00ff': 'magenta',
        '#00ffff': 'cyan',
        '#ffffff': 'white',
        '#808080': 'gray'
    },
    256: {}
};

var diffPalettes = {};

function convertColorToObject(color) {
    if (color.length < 6) {
        // Allow CSS shorthand
        color = color.replace(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i, '$1$1$2$2$3$3');
    }
    // Split color into red, green, and blue components
    var hexMatch = color.match(/^#?([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/i);
    if (hexMatch) {
        return {
            R: parseInt(hexMatch[1], 16),
            G: parseInt(hexMatch[2], 16),
            B: parseInt(hexMatch[3], 16)
        };
    }
}

function toHexColor(colorObject) {
    var hexString = (Math.round(colorObject.R) * 0x10000 + Math.round(colorObject.G) * 0x100 + Math.round(colorObject.B)).toString(16);
    return '#' + ('00000'.substr(0, 6 - hexString.length)) + hexString;
}

function firstUp(text) {
    return text.substring(0, 1).toUpperCase() + text.substring(1);
}

diffPalettes[16] = Object.keys(colorPalettes[16]).map(convertColorToObject);
diffPalettes['bg16'] = Object.keys(colorPalettes[16]).filter(function (color) {
    return color !== "#808080";
}).map(convertColorToObject);
diffPalettes[256] = [].concat(diffPalettes[16]);
var nextAnsiColorNumber = 16;
function registerNext256PaletteEntry(obj) {
    diffPalettes[256].push(obj);
    colorPalettes[256][toHexColor(obj)] = nextAnsiColorNumber;
    nextAnsiColorNumber += 1;
}

for (var r = 0 ; r < 6 ; r += 1) {
    for (var g = 0 ; g < 6 ; g += 1) {
        for (var b = 0 ; b < 6 ; b += 1) {
            registerNext256PaletteEntry({
                R: Math.round(r * 256 / 6),
                G: Math.round(g * 256 / 6),
                B: Math.round(b * 256 / 6)
            });
        }
    }
}

[
    0x08, 0x12, 0x1c, 0x26, 0x30, 0x3a, 0x44, 0x4e, 0x58, 0x60, 0x66, 0x76,
    0x80, 0x8a, 0x94, 0x9e, 0xa8, 0xb2, 0xbc, 0xc6, 0xd0, 0xda, 0xe4, 0xee
].forEach(function (value) {
    registerNext256PaletteEntry({R: value, G: value, B: value});
});

AnsiSerializer.prototype.text = function (options) {
    var content = String(options.content);
    if (content === '') {
        return '';
    }

    var styles = themeMapper(this.theme, options.styles);

    if (styles.length > 0) {
        for (var i = styles.length -1; i >= 0; i -= 1) {
            var styleName = styles[i];

            if (ansiStyles[styleName]) {
                content = ansiStyles[styleName].open + content + ansiStyles[styleName].close;
            } else if (rgbRegexp.test(styleName)) {
                var originalStyleName = styleName;
                var isBackgroundColor = styleName.substring(0, 2) === 'bg';
                var colorName = isBackgroundColor ? styleName.substring(2) : styleName;

                var color16Hex = toHexColor(colorDiff.closest(convertColorToObject(colorName),
                                                              diffPalettes[isBackgroundColor ? 'bg16' : 16]));
                var closestColor16 = colorPalettes[16][color16Hex];

                var color256Hex = toHexColor(colorDiff.closest(convertColorToObject(colorName), diffPalettes[256]));
                var closest256ColorIndex = colorPalettes[256][color256Hex];

                if (isBackgroundColor) {
                    styleName = 'bg' + firstUp(closestColor16);
                } else {
                    styleName = closestColor16;
                }

                var open = ansiStyles[styleName].open;
                var close = ansiStyles[styleName].close;
                if (color16Hex !== color256Hex) {
                    open += '\x1b[' + (isBackgroundColor ? 48 : 38) + ';5;' + closest256ColorIndex + 'm';
                }
                if (cacheSize < maxColorCacheSize) {
                    ansiStyles[originalStyleName] = {open: open, close: close};
                    cacheSize += 1;
                }

                content = open + content + close;
            }
        }
    }

    return content;
};

module.exports = AnsiSerializer;

},{}],2:[function(require,module,exports){
var cssStyles = require(6);
var flattenBlocksInLines = require(8);
var rgbRegexp = require(9);
var themeMapper = require(10);

function ColoredConsoleSerializer(theme) {
    this.theme = theme;
}

ColoredConsoleSerializer.prototype.format = 'coloredConsole';

ColoredConsoleSerializer.prototype.serialize = function (lines) {
    var formatString = '';
    var styleStrings = [];
    this.serializeLines(flattenBlocksInLines(lines)).forEach(function (entry) {
        if (entry) {
            formatString += entry[0];
            if (entry.length > 1) {
                styleStrings.push(entry[1]);
            }
        }
    });
    return [formatString].concat(styleStrings);
};

ColoredConsoleSerializer.prototype.serializeLines = function (lines) {
    var result = [];
    lines.forEach(function (line, i) {
        if (i > 0) {
            result.push(['%c\n ', '']);
        }
        Array.prototype.push.apply(result, this.serializeLine(line));
    }, this);
    return result;
};

ColoredConsoleSerializer.prototype.serializeLine = function (line) {
    var result = [];
    line.forEach(function (outputEntry) {
        if (this[outputEntry.style]) {
            result.push(this[outputEntry.style](outputEntry.args));
        }
    }, this);
    return result;
};

ColoredConsoleSerializer.prototype.block = function (content) {
    return this.serializeLines(content);
};

ColoredConsoleSerializer.prototype.text = function (options) {
    var content = String(options.content);
    if (content === '') {
        return '';
    }

    var styles = themeMapper(this.theme, options.styles);

    var result = ['%c' + content.replace(/%/g, '%%')];
    var styleProperties = [];

    if (styles.length > 0) {
        for (var i = 0; i < styles.length; i += 1) {
            var styleName = styles[i];
            if (rgbRegexp.test(styleName)) {
                if (styleName.substring(0, 2) === 'bg') {
                    styleProperties.push('background-color: ' + styleName.substring(2));
                } else {
                    styleProperties.push('color: ' + styleName);
                }
            } else if (cssStyles[styleName]) {
                styleProperties.push(cssStyles[styleName]);
            }
        }
    }
    result.push(styleProperties.join('; '));
    return result;
};

ColoredConsoleSerializer.prototype.raw = function (options) {
    return String(options.content(this));
};

module.exports = ColoredConsoleSerializer;

},{}],3:[function(require,module,exports){
var cssStyles = require(6);
var rgbRegexp = require(9);
var themeMapper = require(10);

function HtmlSerializer(theme) {
    this.theme = theme;
}

HtmlSerializer.prototype.format = 'html';

HtmlSerializer.prototype.serialize = function (lines) {
    return '<div style="font-family: monospace; white-space: nowrap">' + this.serializeLines(lines) + '</div>';
};

HtmlSerializer.prototype.serializeLines = function (lines) {
    return lines.map(function (line) {
        return '<div>' + (this.serializeLine(line).join('') || '&nbsp;') + '</div>';
    }, this).join('');
};

HtmlSerializer.prototype.serializeLine = function (line) {
    return line.map(function (outputEntry) {
        return this[outputEntry.style] ?
            this[outputEntry.style](outputEntry.args) :
            '';
    }, this);
};

HtmlSerializer.prototype.block = function (content) {
    return '<div style="display: inline-block; vertical-align: top">' +
        this.serializeLines(content) +
        '</div>';
};

HtmlSerializer.prototype.text = function (options) {
    var content = String(options.content);

    if (content === '') {
        return '';
    }

    content = content
        .replace(/&/g, '&amp;')
        .replace(/ /g, '&nbsp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');


    var styles = themeMapper(this.theme, options.styles);

    if (styles.length > 0) {
        var styleProperties = [];
        for (var j = 0; j < styles.length; j += 1) {
            var styleName = styles[j];
            if (rgbRegexp.test(styleName)) {
                if (styleName.substring(0, 2) === 'bg') {
                    styleProperties.push('background-color: ' + styleName.substring(2));
                } else {
                    styleProperties.push('color: ' + styleName);
                }
            } else if (cssStyles[styleName]) {
                styleProperties.push(cssStyles[styleName]);
            }

        }

        if (styleProperties.length > 0) {
            content = '<span style="' + styleProperties.join('; ') + '">' + content + '</span>';
        }
    }
    return content;
};

HtmlSerializer.prototype.raw = function (options) {
    return String(options.content(this));
};

module.exports = HtmlSerializer;

},{}],4:[function(require,module,exports){
(function (process){
/*global window*/
var utils = require(11);
var extend = utils.extend;
var duplicateText = require(7);
var rgbRegexp = require(9);
var cssStyles = require(6);

var builtInStyleNames = [
    'bold', 'dim', 'italic', 'underline', 'inverse', 'hidden',
    'strikeThrough', 'black', 'red', 'green', 'yellow', 'blue',
    'magenta', 'cyan', 'white', 'gray', 'bgBlack', 'bgRed',
    'bgGreen', 'bgYellow', 'bgBlue', 'bgMagenta', 'bgCyan',
    'bgWhite'
];

function MagicPen(options) {
    if (!(this instanceof MagicPen)) {
        return new MagicPen(options);
    }

    options = options || {};

    if (typeof options === "string") {
        options = {format: options };
    }

    var indentationWidth = 'indentationWidth' in options ?
        options.indentationWidth : 2;
    this.indentationWidth = Math.max(indentationWidth, 0);

    this.indentationLevel = 0;
    this.output = [[]];
    this.styles = Object.create(null);
    this.installedPlugins = [];
    // Ready to be cloned individually:
    this._themes = {};
    Object.keys(MagicPen.serializers).forEach(function (serializerName) {
        this._themes[serializerName] = { styles: {} };
    }, this);
    this.preferredWidth = (!process.browser && process.stdout.columns) || 80;
    if (options.format) {
        this.format = options.format;
    }
}

if (typeof exports === 'object' && typeof exports.nodeName !== 'string' && require(18)) {
    MagicPen.defaultFormat = 'ansi'; // colored console
} else if (typeof window !== 'undefined' && typeof window.navigator !== 'undefined') {
    if (window._phantom || window.mochaPhantomJS || (window.__karma__ && window.__karma__.config.captureConsole)) {
        MagicPen.defaultFormat = 'ansi'; // colored console
    } else {
        MagicPen.defaultFormat = 'html'; // Browser
    }
} else {
    MagicPen.defaultFormat = 'text'; // Plain text
}

MagicPen.prototype.newline = MagicPen.prototype.nl = function (count) {
    if (typeof count === 'undefined') {
        count = 1;
    }

    if (count === 0) {
        return this;
    }

    for (var i = 0; i < count; i += 1) {
        this.output.push([]);
    }
    return this;
};

MagicPen.serializers = {};
[
    require(5),
    require(3),
    require(1),
    require(2)
].forEach(function (serializer) {
    MagicPen.serializers[serializer.prototype.format] = serializer;
});

function hasSameTextStyling(a, b) {
    if (!a || !b || a.style !== 'text' || b.style !== 'text') {
        return false;
    }

    return utils.arrayEquals(a.args.styles, b.args.styles);
}

function normalizeLine(line) {
    if (line.length === 0) {
        return line;
    }

    var result = [line[0]];
    for (var i = 1; i < line.length; i += 1) {
        var lastEntry = result[result.length - 1];
        var entry = line[i];
        if (entry.style === 'text' && entry.args.content === '') {
            continue;
        }

        if (hasSameTextStyling(lastEntry, entry)) {
            result[result.length - 1] = {
                style: lastEntry.style,
                args: {
                    content: lastEntry.args.content + entry.args.content,
                    styles: lastEntry.args.styles
                }
            };
        } else {
            result.push(entry);
        }
    }

    return result;
}

MagicPen.prototype.write = function (options) {
    if (this.styles[options.style]) {
        this.styles[options.style].apply(this, options.args);
        return this;
    }
    var lastLine = this.output[this.output.length - 1];
    var lastEntry = lastLine[lastLine.length - 1];
    if (hasSameTextStyling(lastEntry, options)) {
        lastLine[lastLine.length - 1] = {
            style: lastEntry.style,
            args: {
                content: lastEntry.args.content + options.args.content,
                styles: lastEntry.args.styles
            }
        };
    } else {
        lastLine.push(options);
    }

    return this;
};

MagicPen.prototype.indentLines = function () {
    this.indentationLevel += 1;
    return this;
};

MagicPen.prototype.indent = MagicPen.prototype.i = function () {
    for (var i = 0; i < this.indentationLevel; i += 1) {
        this.space(this.indentationWidth);
    }
    return this;
};

MagicPen.prototype.outdentLines = function () {
    this.indentationLevel = Math.max(0, this.indentationLevel - 1);
    return this;
};

MagicPen.prototype.addStyle = function (style, handler, allowRedefinition) {
    if (this[style] === false || ((this.hasOwnProperty(style) || MagicPen.prototype[style]) && !Object.prototype.hasOwnProperty.call(this.styles, style) && builtInStyleNames.indexOf(style) === -1)) {
        throw new Error('"' + style + '" style cannot be defined, it clashes with a built-in attribute');
    }

    // Refuse to redefine a built-in style or a style already defined directly on this pen unless allowRedefinition is true:
    if (this.hasOwnProperty(style) || builtInStyleNames.indexOf(style) !== -1) {
        var existingType = typeof this[style];
        if (existingType === 'function') {
            if (!allowRedefinition) {
                throw new Error('"' + style + '" style is already defined, set 3rd arg (allowRedefinition) to true to define it anyway');
            }
        }
    }
    if (this._stylesHaveNotBeenClonedYet) {
        this.styles = Object.create(this.styles);
        this._stylesHaveNotBeenClonedYet = false;
    }

    this.styles[style] = handler;
    this[style] = function () {
        handler.apply(this, arguments);
        return this;
    };
    return this;
};

MagicPen.prototype.toString = function (format) {
    if (format && this.format && format !== this.format) {
        throw new Error('A pen with format: ' + this.format + ' cannot be serialized to: ' + format);
    }

    format = this.format || format || 'text';
    if (format === 'auto') {
        format = MagicPen.defaultFormat;
    }
    var theme = this._themes[format] || {};
    var serializer = new MagicPen.serializers[format](theme);
    return serializer.serialize(this.output);
};

MagicPen.prototype.text = function () {
    var content = arguments[0];
    if (content === '') {
        return this;
    }

    var styles = new Array(arguments.length - 1);
    for (var i = 1; i < arguments.length; i += 1) {
        styles[i - 1] = arguments[i];
    }

    content = String(content);
    if (content.indexOf('\n') !== -1) {
        var lines = content.split(/\n/);
        lines.forEach(function (lineContent, index) {
            if (lineContent.length) {
                this.write({
                    style: 'text',
                    args: { content: lineContent, styles: styles }
                });
            }
            if (index < lines.length - 1) {
                this.nl();
            }
        }, this);
        return this;
    } else {
        return this.write({
            style: 'text',
            args: { content: content, styles: styles }
        });
    }
};

MagicPen.prototype.removeFormatting = function () {
    var result = this.clone();
    this.output.forEach(function (line, index) {
        result.output[index] = normalizeLine(line.map(function (outputEntry) {
            return outputEntry.style === 'text' ?
                { style: 'text', args: { content: outputEntry.args.content, styles: [] } } :
                outputEntry;
        }));
    });
    result.indentationLevel = this.indentationLevel;
    return result;
};

MagicPen.prototype.getContentFromArguments = function (args) {
    var clone;
    if (args[0].isMagicPen) {
        this.ensureCompatibleFormat(args[0].format);
        return args[0];
    } else if (typeof args[0] === 'function') {
        clone = this.clone();
        args[0].call(clone, clone);
        return clone;
    } else if (typeof args[0] === 'string' && args.length === 1) {
        clone = this.clone();
        clone.text(args[0]);
        return clone;
    } else if (typeof args[0] === 'string') {
        clone = this.clone();
        clone[args[0]].apply(clone, Array.prototype.slice.call(args, 1));
        return clone;
    } else {
        throw new Error('Requires the arguments to be:\n' +
                        'a pen or\n' +
                        'a callback appending content to a pen or\n' +
                        'a style and arguments for that style or\n' +
                        'just a string.');
    }
};

MagicPen.prototype.isMultiline = function () {
    return this.output.length > 1 || this.size().height > 1;
};

MagicPen.prototype.isAtStartOfLine = function () {
    return this.output.length === 0 || this.output[this.output.length - 1].length === 0;
};

MagicPen.prototype.isBlock = function () {
    return this.output.length === 1 &&
        this.output[0].length === 1 &&
        this.output[0][0].style === 'block';
};

MagicPen.prototype.ensureCompatibleFormat = function (format) {
    if (format && this.format && format !== this.format) {
        throw new Error('This pen is only compatible with the format: ' + this.format);
    }
};

MagicPen.prototype.block = function () {
    var pen = this.getContentFromArguments(arguments);

    var blockOutput = pen.output.map(function (line) {
        return [].concat(line);
    });
    return this.write({ style: 'block', args: blockOutput });
};
function isRawOutput(options) {
    return options &&
        typeof options === 'object' &&
        typeof options.width === 'number' &&
        typeof options.height === 'number' && (
            typeof options.content === 'function' ||
                typeof options.content === 'string'
        );
}

MagicPen.prototype.alt = function (options) {
    var format = this.format;
    if (!format) {
        throw new Error('The alt method is only supported on pen where the format has already been set');
    }

    var outputProperty = options[format];

    if (typeof outputProperty === 'undefined') {
        if (options.fallback) {
            return this.append(options.fallback);
        } else {
            // Nothing to do for this format, just NOOP:
            return this;
        }
    }

    if (typeof outputProperty === 'string' || isRawOutput(outputProperty)) {
        return this.raw(outputProperty);
    } else {
        return this.append(outputProperty);
    }
};

MagicPen.prototype.raw = function (options) {
    var format = this.format;
    if (!format) {
        throw new Error('The alt method is only supported on pen where the format has already been set');
    }

    if (typeof options === 'string') {
        return this.write({ style: 'raw', args: {
            height: 0,
            width: 0,
            content: function () {
                return options;
            }
        }});
    }

    if (isRawOutput(options)) {
        if (typeof options.content === 'string') {
            options = extend({}, options);
            var content = options.content;
            options.content = function () {
                return content;
            };
        }

        return this.write({ style: 'raw', args: options });
    }

    throw new Error('Raw ' + this.format + ' content needs to adhere to one of the following forms:\n' +
                    'a string of raw content\n' +
                    'a function returning a string of raw content or\n' +
                    'an object with the following form { width: <number>, height: <number>, content: <string function() {}|string> }');
};

function amend(output, pen) {
    var lastLine = output[output.length - 1].slice();
    var newOutput = output.slice(0, -1);
    var lastEntry = lastLine[lastLine.length - 1];
    if (lastEntry && lastEntry.style === 'block') {
        lastLine[lastLine.length - 1] = {
            style: 'block',
            args: amend(lastEntry.args, pen)
        };
        newOutput[output.length - 1] = lastLine;
    } else {
        Array.prototype.push.apply(lastLine, pen.output[0]);
        newOutput[output.length - 1] = normalizeLine(lastLine);
        newOutput.push.apply(newOutput, pen.output.slice(1));
    }

    return newOutput;
}

MagicPen.prototype.amend = function () {
    var pen = this.getContentFromArguments(arguments);

    if (pen.isEmpty()) {
        return this;
    }

    this.output = amend(this.output, pen);

    return this;
};

MagicPen.prototype.append = function () {
    var pen = this.getContentFromArguments(arguments);

    if (pen.isEmpty()) {
        return this;
    }

    var lastLine = this.output[this.output.length - 1];
    Array.prototype.push.apply(lastLine, pen.output[0]);
    this.output[this.output.length - 1] = normalizeLine(lastLine);

    this.output.push.apply(this.output, pen.output.slice(1));

    return this;
};

MagicPen.prototype.prependLinesWith = function () {
    var pen = this.getContentFromArguments(arguments);

    if (pen.isEmpty()) {
        return this;
    }

    if (pen.output.length > 1) {
        throw new Error('PrependLinesWith only supports a pen with single line content');
    }

    var height = this.size().height;
    var output = this.clone();
    output.block(function () {
        for (var i = 0; i < height; i += 1) {
            if (0 < i) {
                this.nl();
            }
            this.append(pen);
        }
    });
    output.block(this);

    this.output = output.output;
    return this;
};

MagicPen.prototype.space = MagicPen.prototype.sp = function (count) {
    if (count === 0) {
        return this;
    }

    if (typeof count === 'undefined') {
        count = 1;
    }

    return this.text(duplicateText(' ', count));
};

builtInStyleNames.forEach(function (textStyle) {
    MagicPen.prototype[textStyle] = MagicPen.prototype[textStyle.toLowerCase()] = function (content) {
        return this.text(content, textStyle);
    };
});

MagicPen.prototype.clone = function (format) {
    if (!this.isEmpty()) {
        this.ensureCompatibleFormat(format);
    }

    function MagicPenClone() {}
    MagicPenClone.prototype = this;
    var clonedPen = new MagicPenClone();
    clonedPen.styles = this.styles;
    clonedPen._stylesHaveNotBeenClonedYet = true;
    clonedPen.indentationLevel = 0;
    clonedPen.output = [[]];
    clonedPen.installedPlugins = [];
    clonedPen._themes = this._themes;
    clonedPen._themesHaveNotBeenClonedYet = true;
    clonedPen.format = format || this.format;
    clonedPen.parent = this;
    return clonedPen;
};

MagicPen.prototype.isMagicPen = true;

MagicPen.prototype.size = function () {
    return utils.calculateSize(this.output);
};

MagicPen.prototype.use = function (plugin) {
    var existingPlugin = utils.findFirst(this.installedPlugins, function (installedPlugin) {
        if (installedPlugin === plugin) {
            return true;
        } else if (typeof plugin === 'function' && typeof installedPlugin === 'function') {
            var pluginName = utils.getFunctionName(plugin);
            return pluginName !== '' && pluginName === utils.getFunctionName(installedPlugin);
        } else {
            return installedPlugin.name === plugin.name;
        }
    });

    if (existingPlugin) {
        if (existingPlugin === plugin || (typeof plugin.version !== 'undefined' && plugin.version === existingPlugin.version)) {
            // No-op
            return this;
        } else {
            throw new Error("Another instance of the plugin '" + plugin.name + "' " +
                            "is already installed" +
                            (typeof existingPlugin.version !== 'undefined' ?
                                ' (version ' + existingPlugin.version +
                                (typeof plugin.version !== 'undefined' ?
                                    ', trying to install ' + plugin.version : '') +
                                ')' : '') +
                            ". Please check your node_modules folder for unmet peerDependencies.");
        }
    }

    if ((typeof plugin !== 'function' && (typeof plugin !== 'object' || typeof plugin.installInto !== 'function')) ||
        (typeof plugin.name !== 'undefined' && typeof plugin.name !== 'string') ||
        (typeof plugin.dependencies !== 'undefined' && !Array.isArray(plugin.dependencies))) {
        throw new Error('Plugins must be functions or adhere to the following interface\n' +
                        '{\n' +
                        '  name: <an optional plugin name>,\n' +
                        '  version: <an optional semver version string>,\n' +
                        '  dependencies: <an optional list of dependencies>,\n' +
                        '  installInto: <a function that will update the given magicpen instance>\n' +
                        '}');
    }

    if (plugin.dependencies) {
        var instance = this;
        var thisAndParents = [];
        do {
            thisAndParents.push(instance);
            instance = instance.parent;
        } while (instance);
        var unfulfilledDependencies = plugin.dependencies.filter(function (dependency) {
            return !thisAndParents.some(function (instance) {
                return instance.installedPlugins.some(function (plugin) {
                    return plugin.name === dependency;
                });
            });
        });

        if (unfulfilledDependencies.length === 1) {
            throw new Error(plugin.name + ' requires plugin ' + unfulfilledDependencies[0]);
        } else if (unfulfilledDependencies.length > 1) {
            throw new Error(plugin.name + ' requires plugins ' +
                            unfulfilledDependencies.slice(0, -1).join(', ') +
                            ' and ' + unfulfilledDependencies[unfulfilledDependencies.length - 1]);
        }
    }

    this.installedPlugins.push(plugin);
    if (typeof plugin === 'function') {
        plugin(this);
    } else {
        plugin.installInto(this);
    }

    return this; // for chaining
};

MagicPen.prototype.installPlugin = MagicPen.prototype.use; // Legacy alias

function replaceText(output, outputArray, regexp, cb) {
    var replacedOutput = output;
    outputArray.forEach(function (line, i) {
        if (0 < i) {
            replacedOutput.nl();
        }

        line.forEach(function (outputEntry, j) {
            if (outputEntry.style === 'block') {
                return replacedOutput.output[replacedOutput.output.length - 1].push({
                    style: 'block',
                    args: replaceText(output.clone(), outputEntry.args, regexp, cb)
                });
            } else if (outputEntry.style !== 'text') {
                return replacedOutput.output[replacedOutput.output.length - 1].push(outputEntry);
            }

            if (regexp.global) {
                regexp.lastIndex = 0;
            }
            var m;
            var first = true;
            var lastIndex = 0;
            var text = outputEntry.args.content;
            var styles = outputEntry.args.styles;
            while ((m = regexp.exec(text)) !== null && (regexp.global || first)) {
                if (lastIndex < m.index) {
                    replacedOutput.text.apply(replacedOutput, [text.substring(lastIndex, m.index)].concat(styles));
                }

                cb.apply(replacedOutput, [styles].concat(m));
                first = false;
                lastIndex = m.index + m[0].length;
            }

            if (lastIndex === 0) {
                var lastLine;
                if (replacedOutput.output.length === 0) {
                    lastLine = replacedOutput.output[0] = [];
                } else {
                    lastLine = replacedOutput.output[replacedOutput.output.length - 1];
                }

                lastLine.push(outputEntry);
            } else if (lastIndex < text.length) {
                replacedOutput.text.apply(replacedOutput, [text.substring(lastIndex, text.length)].concat(styles));
            }
        }, this);
    }, this);

    return replacedOutput.output.map(normalizeLine);
}

MagicPen.prototype.isEmpty = function () {
    return this.output.length === 1 && this.output[0].length === 0;
};

MagicPen.prototype.replaceText = function (regexp, cb) {
    if (this.isEmpty()) {
        return this;
    }

    if (typeof regexp === 'string') {
        regexp = new RegExp(utils.escapeRegExp(regexp), 'g');
    }

    if (typeof cb === 'string') {
        var text = cb;
        cb = function (styles, _) {
            var args = [text].concat(styles);
            this.text.apply(this, args);
        };
    }


    if (arguments.length === 1) {
        cb = regexp;
        regexp = /.*/;
    }

    this.output = replaceText(this.clone(), this.output, regexp, cb);

    return this;
};

MagicPen.prototype.theme = function (format) {
    format = format || this.format;
    if (!format) {
        throw new Error("Could not detect which format you want to retrieve " +
                        "theme information for. Set the format of the pen or " +
                        "provide it as an argument to the theme method.");
    }

    return this._themes[format];
};

MagicPen.prototype.installTheme = function (formats, theme) {
    var that = this;
    if (arguments.length === 1) {
        theme = formats;
        formats = Object.keys(MagicPen.serializers);
    }

    if (typeof formats === 'string') {
        formats = [formats];
    }

    if (
        typeof theme !== 'object' ||
        !Array.isArray(formats) ||
        formats.some(function (format) {
            return typeof format !== 'string';
        })
    ) {
        throw new Error("Themes must be installed the following way:\n" +
                        "Install theme for all formats: pen.installTheme({ comment: 'gray' })\n" +
                        "Install theme for a specific format: pen.installTheme('ansi', { comment: 'gray' }) or\n" +
                        "Install theme for a list of formats: pen.installTheme(['ansi', 'html'], { comment: 'gray' })");
    }

    if (!theme.styles || typeof theme.styles !== 'object') {
        theme = {
            styles: theme
        };
    }

    if (that._themesHaveNotBeenClonedYet) {
        var clonedThemes = {};
        Object.keys(that._themes).forEach(function (format) {
            clonedThemes[format] = Object.create(that._themes[format]);
        });
        that._themes = clonedThemes;
        that._themesHaveNotBeenClonedYet = false;
    }

    Object.keys(theme.styles).forEach(function (themeKey) {
        if (rgbRegexp.test(themeKey) || cssStyles[themeKey]) {
            throw new Error("Invalid theme key: '" + themeKey + "' you can't map build styles.");
        }

        if (!that[themeKey]) {
            that.addStyle(themeKey, function (content) {
                this.text(content, themeKey);
            });
        }
    });

    formats.forEach(function (format) {
        var baseTheme = that._themes[format] || { styles: {} };
        var extendedTheme = extend({}, baseTheme, theme);
        extendedTheme.styles = extend({}, baseTheme.styles, theme.styles);
        that._themes[format] = extendedTheme;
    });


    return this;
};

module.exports = MagicPen;

}).call(this,require(13))
},{}],5:[function(require,module,exports){
var flattenBlocksInLines = require(8);

function TextSerializer() {}

TextSerializer.prototype.format = 'text';

TextSerializer.prototype.serialize = function (lines) {
    lines = flattenBlocksInLines(lines);
    return lines.map(this.serializeLine, this).join('\n');
};

TextSerializer.prototype.serializeLine = function (line) {
    return line.map(function (outputEntry) {
        return this[outputEntry.style] ?
            String(this[outputEntry.style](outputEntry.args)) :
            '';
    }, this).join('');
};

TextSerializer.prototype.text = function (options) {
    return String(options.content);
};

TextSerializer.prototype.block = function (content) {
    return this.serialize(content);
};

TextSerializer.prototype.raw = function (options) {
    return String(options.content(this));
};


module.exports = TextSerializer;

},{}],6:[function(require,module,exports){
var cssStyles = {
    bold: 'font-weight: bold',
    dim: 'opacity: 0.7',
    italic: 'font-style: italic',
    underline: 'text-decoration: underline',
    inverse: '-webkit-filter: invert(%100); filter: invert(100%)',
    hidden: 'visibility: hidden',
    strikeThrough: 'text-decoration: line-through',

    black: 'color: black',
    red: 'color: red',
    green: 'color: green',
    yellow: 'color: yellow',
    blue: 'color: blue',
    magenta: 'color: magenta',
    cyan: 'color: cyan',
    white: 'color: white',
    gray: 'color: gray',

    bgBlack: 'background-color: black',
    bgRed: 'background-color: red',
    bgGreen: 'background-color: green',
    bgYellow: 'background-color: yellow',
    bgBlue: 'background-color: blue',
    bgMagenta: 'background-color: magenta',
    bgCyan: 'background-color: cyan',
    bgWhite: 'background-color: white'
};

Object.keys(cssStyles).forEach(function (styleName) {
    cssStyles[styleName.toLowerCase()] = cssStyles[styleName];
});

module.exports = cssStyles;

},{}],7:[function(require,module,exports){
var whitespaceCacheLength = 256;
var whitespaceCache = [''];
for (var i = 1; i <= whitespaceCacheLength; i += 1) {
    whitespaceCache[i] = whitespaceCache[i - 1] + ' ';
}

function duplicateText(content, times) {
    if (times < 0) {
        return '';
    }

    var result = '';

    if (content === ' ') {
        if (times <= whitespaceCacheLength) {
            return whitespaceCache[times];
        }

        var segment = whitespaceCache[whitespaceCacheLength];
        var numberOfSegments = Math.floor(times / whitespaceCacheLength);
        for (var i = 0; i < numberOfSegments; i += 1) {
            result += segment;
        }
        result += whitespaceCache[times % whitespaceCacheLength];
    } else {
        for (var j = 0; j < times; j += 1) {
            result += content;
        }
    }

    return result;
}

module.exports = duplicateText;

},{}],8:[function(require,module,exports){
var utils = require(11);
var duplicateText = require(7);

function createPadding(length) {
    return { style: 'text', args: { content: duplicateText(' ', length), styles: [] } };
}

function lineContainsBlocks(line) {
    return line.some(function (outputEntry) {
        return outputEntry.style === 'block' ||
            (outputEntry.style === 'text' && String(outputEntry.args.content).indexOf('\n') !== -1);
    });
}

function flattenBlocksInOutputEntry(outputEntry) {
    switch (outputEntry.style) {
    case 'text': return String(outputEntry.args.content).split('\n').map(function (line) {
        if (line === '') {
            return [];
        }

        var args = { content: line, styles: outputEntry.args.styles };
        return [{ style: 'text', args: args }];
    });
    case 'block': return flattenBlocksInLines(outputEntry.args);
    default: return [];
    }
}

function flattenBlocksInLine(line) {
    if (line.length === 0) {
       return [[]];
    }

    if (!lineContainsBlocks(line)) {
        return [line];
    }

    var result = [];
    var linesLengths = [];

    var startIndex = 0;
    line.forEach(function (outputEntry, blockIndex) {
        var blockLines = flattenBlocksInOutputEntry(outputEntry);

        var blockLinesLengths = blockLines.map(function (line) {
            return utils.calculateLineSize(line).width;
        });

        var longestLineLength = Math.max.apply(null, blockLinesLengths);

        blockLines.forEach(function (blockLine, index) {
            var resultLine = result[index];

            if (!resultLine) {
                result[index] = resultLine = [];
                linesLengths[index] = 0;
            }

            if (blockLine.length) {
                var paddingLength = startIndex - linesLengths[index];
                resultLine.push(createPadding(paddingLength));
                Array.prototype.push.apply(resultLine, blockLine);
                linesLengths[index] = startIndex + blockLinesLengths[index];
            }
        });

        startIndex += longestLineLength;
    }, this);
    return result;
}

function flattenBlocksInLines(lines) {
    var result = [];
    lines.forEach(function (line) {
        flattenBlocksInLine(line).forEach(function (line) {
            result.push(line);
        });
    });
    return result;
}

module.exports = flattenBlocksInLines;

},{}],9:[function(require,module,exports){
module.exports =  /^(?:bg)?#(?:[0-9a-f]{3}|[0-9a-f]{6})$/i;

},{}],10:[function(require,module,exports){
module.exports = function (theme, styles) {
    if (styles.length === 1) {
        var count = 0;
        var stack = [];
        var themeMapping = styles[0];
        var themeStyles = theme.styles || {};
        while(typeof themeMapping === 'string' && themeStyles[themeMapping]) {
            themeMapping = themeStyles[themeMapping];
            count += 1;
            if (100 < count) {
                var index = stack.indexOf(themeMapping);
                stack.push(themeMapping);
                if (index !== -1) {
                    throw new Error('Your theme contains a loop: ' + stack.slice(index).join(' -> '));
                }
            }
        }

        return Array.isArray(themeMapping) ? themeMapping : [themeMapping];
    }

    return styles;
};

},{}],11:[function(require,module,exports){
var utils = {
    extend: function (target) {
        for (var i = 1; i < arguments.length; i += 1) {
            var source = arguments[i];
            Object.keys(source).forEach(function (key) {
                target[key] = source[key];
            });
        }
        return target;
    },

    calculateOutputEntrySize: function (outputEntry) {
        if (outputEntry.size) {
            return outputEntry.size;
        }

        var size;
        switch (outputEntry.style) {
        case 'text':
            size = { width: String(outputEntry.args.content).length, height: 1 };
            break;
        case 'block':
            size = utils.calculateSize(outputEntry.args);
            break;
        case 'raw':
            var arg = outputEntry.args;
            size = { width: arg.width, height: arg.height };
            break;
        default: size = { width: 0, height: 0 };
        }

        outputEntry.size = size;
        return size;
    },

    calculateLineSize: function (line) {
        var size = { height: 1, width: 0 };
        line.forEach(function (outputEntry) {
            var outputEntrySize = utils.calculateOutputEntrySize(outputEntry);
            size.width += outputEntrySize.width;
            size.height = Math.max(outputEntrySize.height, size.height);
        });
        return size;
    },

    calculateSize: function (lines) {
        var size = { height: 0, width: 0 };
        lines.forEach(function (line) {
            var lineSize = utils.calculateLineSize(line);
            size.height += lineSize.height;
            size.width = Math.max(size.width, lineSize.width);
        });
        return size;
    },

    arrayEquals: function (a, b) {
        if (a === b) {
            return true;
        }

        if (!a || a.length !== b.length) {
            return false;
        }

        for (var i = 0; i < a.length; i += 1) {
            if (a[i] !== b[i]) {
                return false;
            }
        }

        return true;

    },

    escapeRegExp: function (text){
        return text.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
    },

    findFirst: function (arr, predicate, thisObj) {
        var scope = thisObj || null;
        for (var i = 0 ; i < arr.length ; i += 1) {
            if (predicate.call(scope, arr[i], i, arr)) {
                return arr[i];
            }
        }
        return null;
    },

    getFunctionName: function (f) {
        if (typeof f.name === 'string') {
            return f.name;
        }
        var matchFunctionName = Function.prototype.toString.call(f).match(/function ([^\(]+)/);
        if (matchFunctionName) {
            return matchFunctionName[1];
        }

        if (f === Object) {
            return 'Object';
        }
        if (f === Function) {
            return 'Function';
        }
    }
};

module.exports = utils;

},{}],12:[function(require,module,exports){
'use strict';

var styles = module.exports = {
	modifiers: {
		reset: [0, 0],
		bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29]
	},
	colors: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],
		gray: [90, 39]
	},
	bgColors: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49]
	}
};

// fix humans
styles.colors.grey = styles.colors.gray;

Object.keys(styles).forEach(function (groupName) {
	var group = styles[groupName];

	Object.keys(group).forEach(function (styleName) {
		var style = group[styleName];

		styles[styleName] = group[styleName] = {
			open: '\u001b[' + style[0] + 'm',
			close: '\u001b[' + style[1] + 'm'
		};
	});

	Object.defineProperty(styles, groupName, {
		value: group,
		enumerable: false
	});
});

},{}],13:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],14:[function(require,module,exports){
/**
 * @author Markus Ekholm
 * @copyright 2012-2015 (c) Markus Ekholm <markus at botten dot org >
 * @license Copyright (c) 2012-2015, Markus Ekholm
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the <organization> nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL MARKUS EKHOLM BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
* EXPORTS
*/
exports.rgb_to_lab = rgb_to_lab;

/**
* IMPORTS
*/
var pow  = Math.pow;
var sqrt = Math.sqrt;

/**
 * API FUNCTIONS
 */

/**
* Returns c converted to labcolor.
* @param {rgbcolor} c should have fields R,G,B
* @return {labcolor} c converted to labcolor
*/
function rgb_to_lab(c)
{
  return xyz_to_lab(rgb_to_xyz(c))
}

/**
* Returns c converted to xyzcolor.
* @param {rgbcolor} c should have fields R,G,B
* @return {xyzcolor} c converted to xyzcolor
*/
function rgb_to_xyz(c)
{
  // Based on http://www.easyrgb.com/index.php?X=MATH&H=02
  var R = ( c.R / 255 );
  var G = ( c.G / 255 );
  var B = ( c.B / 255 );

  if ( R > 0.04045 ) R = pow(( ( R + 0.055 ) / 1.055 ),2.4);
  else               R = R / 12.92;
  if ( G > 0.04045 ) G = pow(( ( G + 0.055 ) / 1.055 ),2.4);
  else               G = G / 12.92;
  if ( B > 0.04045 ) B = pow(( ( B + 0.055 ) / 1.055 ), 2.4);
  else               B = B / 12.92;

  R *= 100;
  G *= 100;
  B *= 100;

  // Observer. = 2°, Illuminant = D65
  var X = R * 0.4124 + G * 0.3576 + B * 0.1805;
  var Y = R * 0.2126 + G * 0.7152 + B * 0.0722;
  var Z = R * 0.0193 + G * 0.1192 + B * 0.9505;
  return {'X' : X, 'Y' : Y, 'Z' : Z};
}

/**
* Returns c converted to labcolor.
* @param {xyzcolor} c should have fields X,Y,Z
* @return {labcolor} c converted to labcolor
*/
function xyz_to_lab(c)
{
  // Based on http://www.easyrgb.com/index.php?X=MATH&H=07
  var ref_Y = 100.000;
  var ref_Z = 108.883;
  var ref_X = 95.047; // Observer= 2°, Illuminant= D65
  var Y = c.Y / ref_Y;
  var Z = c.Z / ref_Z;
  var X = c.X / ref_X;
  if ( X > 0.008856 ) X = pow(X, 1/3);
  else                X = ( 7.787 * X ) + ( 16 / 116 );
  if ( Y > 0.008856 ) Y = pow(Y, 1/3);
  else                Y = ( 7.787 * Y ) + ( 16 / 116 );
  if ( Z > 0.008856 ) Z = pow(Z, 1/3);
  else                Z = ( 7.787 * Z ) + ( 16 / 116 );
  var L = ( 116 * Y ) - 16;
  var a = 500 * ( X - Y );
  var b = 200 * ( Y - Z );
  return {'L' : L , 'a' : a, 'b' : b};
}

// Local Variables:
// allout-layout: t
// js-indent-level: 2
// End:

},{}],15:[function(require,module,exports){
/**
 * @author Markus Ekholm
 * @copyright 2012-2015 (c) Markus Ekholm <markus at botten dot org >
 * @license Copyright (c) 2012-2015, Markus Ekholm
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the <organization> nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL MARKUS EKHOLM BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
* EXPORTS
*/
exports.ciede2000 = ciede2000;

/**
* IMPORTS
*/
var sqrt = Math.sqrt;
var pow = Math.pow;
var cos = Math.cos;
var atan2 = Math.atan2;
var sin = Math.sin;
var abs = Math.abs;
var exp = Math.exp;
var PI = Math.PI;

/**
 * API FUNCTIONS
 */

/**
* Returns diff between c1 and c2 using the CIEDE2000 algorithm
* @param {labcolor} c1    Should have fields L,a,b
* @param {labcolor} c2    Should have fields L,a,b
* @return {float}   Difference between c1 and c2
*/
function ciede2000(c1,c2)
{
  /**
   * Implemented as in "The CIEDE2000 Color-Difference Formula:
   * Implementation Notes, Supplementary Test Data, and Mathematical Observations"
   * by Gaurav Sharma, Wencheng Wu and Edul N. Dalal.
   */

  // Get L,a,b values for color 1
  var L1 = c1.L;
  var a1 = c1.a;
  var b1 = c1.b;

  // Get L,a,b values for color 2
  var L2 = c2.L;
  var a2 = c2.a;
  var b2 = c2.b;

  // Weight factors
  var kL = 1;
  var kC = 1;
  var kH = 1;

  /**
   * Step 1: Calculate C1p, C2p, h1p, h2p
   */
  var C1 = sqrt(pow(a1, 2) + pow(b1, 2)) //(2)
  var C2 = sqrt(pow(a2, 2) + pow(b2, 2)) //(2)

  var a_C1_C2 = (C1+C2)/2.0;             //(3)

  var G = 0.5 * (1 - sqrt(pow(a_C1_C2 , 7.0) /
                          (pow(a_C1_C2, 7.0) + pow(25.0, 7.0)))); //(4)

  var a1p = (1.0 + G) * a1; //(5)
  var a2p = (1.0 + G) * a2; //(5)

  var C1p = sqrt(pow(a1p, 2) + pow(b1, 2)); //(6)
  var C2p = sqrt(pow(a2p, 2) + pow(b2, 2)); //(6)

  var hp_f = function(x,y) //(7)
  {
    if(x== 0 && y == 0) return 0;
    else{
      var tmphp = degrees(atan2(x,y));
      if(tmphp >= 0) return tmphp
      else           return tmphp + 360;
    }
  }

  var h1p = hp_f(b1, a1p); //(7)
  var h2p = hp_f(b2, a2p); //(7)

  /**
   * Step 2: Calculate dLp, dCp, dHp
   */
  var dLp = L2 - L1; //(8)
  var dCp = C2p - C1p; //(9)

  var dhp_f = function(C1, C2, h1p, h2p) //(10)
  {
    if(C1*C2 == 0)               return 0;
    else if(abs(h2p-h1p) <= 180) return h2p-h1p;
    else if((h2p-h1p) > 180)     return (h2p-h1p)-360;
    else if((h2p-h1p) < -180)    return (h2p-h1p)+360;
    else                         throw(new Error());
  }
  var dhp = dhp_f(C1,C2, h1p, h2p); //(10)
  var dHp = 2*sqrt(C1p*C2p)*sin(radians(dhp)/2.0); //(11)

  /**
   * Step 3: Calculate CIEDE2000 Color-Difference
   */
  var a_L = (L1 + L2) / 2.0; //(12)
  var a_Cp = (C1p + C2p) / 2.0; //(13)

  var a_hp_f = function(C1, C2, h1p, h2p) { //(14)
    if(C1*C2 == 0)                                      return h1p+h2p
    else if(abs(h1p-h2p)<= 180)                         return (h1p+h2p)/2.0;
    else if((abs(h1p-h2p) > 180) && ((h1p+h2p) < 360))  return (h1p+h2p+360)/2.0;
    else if((abs(h1p-h2p) > 180) && ((h1p+h2p) >= 360)) return (h1p+h2p-360)/2.0;
    else                                                throw(new Error());
  }
  var a_hp = a_hp_f(C1,C2,h1p,h2p); //(14)
  var T = 1-0.17*cos(radians(a_hp-30))+0.24*cos(radians(2*a_hp))+
    0.32*cos(radians(3*a_hp+6))-0.20*cos(radians(4*a_hp-63)); //(15)
  var d_ro = 30 * exp(-(pow((a_hp-275)/25,2))); //(16)
  var RC = sqrt((pow(a_Cp, 7.0)) / (pow(a_Cp, 7.0) + pow(25.0, 7.0)));//(17)
  var SL = 1 + ((0.015 * pow(a_L - 50, 2)) /
                sqrt(20 + pow(a_L - 50, 2.0)));//(18)
  var SC = 1 + 0.045 * a_Cp;//(19)
  var SH = 1 + 0.015 * a_Cp * T;//(20)
  var RT = -2 * RC * sin(radians(2 * d_ro));//(21)
  var dE = sqrt(pow(dLp /(SL * kL), 2) + pow(dCp /(SC * kC), 2) +
                pow(dHp /(SH * kH), 2) + RT * (dCp /(SC * kC)) *
                (dHp / (SH * kH))); //(22)
  return dE;
}

/**
 * INTERNAL FUNCTIONS
 */
function degrees(n) { return n*(180/PI); }
function radians(n) { return n*(PI/180); }

// Local Variables:
// allout-layout: t
// js-indent-level: 2
// End:

},{}],16:[function(require,module,exports){
'use strict';

var diff = require(15);
var convert = require(14);
var palette = require(17);

var color = module.exports = {};

color.diff             = diff.ciede2000;
color.rgb_to_lab       = convert.rgb_to_lab;
color.map_palette      = palette.map_palette;
color.palette_map_key  = palette.palette_map_key;

color.closest = function(target, relative) {
    var key = color.palette_map_key(target);

    var result = color.map_palette([target], relative, 'closest');

    return result[key];
};

color.furthest = function(target, relative) {
    var key = color.palette_map_key(target);

    var result = color.map_palette([target], relative, 'furthest');

    return result[key];
};

},{}],17:[function(require,module,exports){
/**
 * @author Markus Ekholm
 * @copyright 2012-2015 (c) Markus Ekholm <markus at botten dot org >
 * @license Copyright (c) 2012-2015, Markus Ekholm
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the <organization> nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL MARKUS EKHOLM BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
* EXPORTS
*/
exports.map_palette     = map_palette;
exports.palette_map_key = palette_map_key;

/**
* IMPORTS
*/
var color_diff    = require(15);
var color_convert = require(14);

/**
 * API FUNCTIONS
 */

/**
* Returns the hash key used for a {rgbcolor} in a {palettemap}
* @param {rgbcolor} c should have fields R,G,B
* @return {string}
*/
function palette_map_key(c)
{
  return "R" + c.R + "B" + c.B + "G" + c.G;
}

/**
* Returns a mapping from each color in a to the closest color in b
* @param [{rgbcolor}] a each element should have fields R,G,B
* @param [{rgbcolor}] b each element should have fields R,G,B
* @param 'type' should be the string 'closest' or 'furthest'
* @return {palettemap}
*/
function map_palette(a, b, type)
{
  var c = {};
  type = type || 'closest';
  for (var idx1 = 0; idx1 < a.length; idx1 += 1){
    var color1 = a[idx1];
    var best_color      = undefined;
    var best_color_diff = undefined;
    for (var idx2 = 0; idx2 < b.length; idx2 += 1)
    {
      var color2 = b[idx2];
      var current_color_diff = diff(color1,color2);

      if((best_color == undefined) || ((type === 'closest') && (current_color_diff < best_color_diff)))
      {
        best_color      = color2;
        best_color_diff = current_color_diff;
        continue;
      }
      if((type === 'furthest') && (current_color_diff > best_color_diff))
      {
        best_color      = color2;
        best_color_diff = current_color_diff;
        continue;
      }
    }
    c[palette_map_key(color1)] = best_color;
  }
  return c;
}

/**
 * INTERNAL FUNCTIONS
 */

function diff(c1,c2)
{
  c1 = color_convert.rgb_to_lab(c1);
  c2 = color_convert.rgb_to_lab(c2);
  return color_diff.ciede2000(c1,c2);
}

// Local Variables:
// allout-layout: t
// js-indent-level: 2
// End:

},{}],18:[function(require,module,exports){
(function (process){
'use strict';
var argv = process.argv;

module.exports = (function () {
	if (argv.indexOf('--no-color') !== -1 ||
		argv.indexOf('--no-colors') !== -1 ||
		argv.indexOf('--color=false') !== -1) {
		return false;
	}

	if (argv.indexOf('--color') !== -1 ||
		argv.indexOf('--colors') !== -1 ||
		argv.indexOf('--color=true') !== -1 ||
		argv.indexOf('--color=always') !== -1) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require(13))
},{}]},{},[4])(4)
});