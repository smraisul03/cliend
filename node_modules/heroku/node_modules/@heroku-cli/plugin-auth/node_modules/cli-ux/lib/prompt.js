"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const config_1 = tslib_1.__importDefault(require("./config"));
const deps_1 = tslib_1.__importDefault(require("./deps"));
exports.default = {
    prompt(name, options = {}) {
        return config_1.default.action.pauseAsync(() => {
            return _prompt(name, options);
        }, chalk_1.default.cyan('?'));
    },
    confirm(message) {
        return config_1.default.action.pauseAsync(async () => {
            const confirm = async () => {
                let response = (await _prompt(message)).toLowerCase();
                if (['n', 'no'].includes(response))
                    return false;
                if (['y', 'yes'].includes(response))
                    return true;
                return confirm();
            };
            return confirm();
        }, chalk_1.default.cyan('?'));
    }
};
function _prompt(name, inputOptions = {}) {
    let prompt = '> ';
    if (name && inputOptions.default)
        prompt = name + ' ' + chalk_1.default.yellow('[' + inputOptions.default + ']') + ': ';
    else if (name)
        prompt = `${name}: `;
    const options = Object.assign({ isTTY: !!(process.env.TERM !== 'dumb' && process.stdin.isTTY), name,
        prompt, type: 'normal', required: true }, inputOptions);
    switch (options.type) {
        case 'normal':
            return normal(options);
        case 'mask':
        case 'hide':
            return deps_1.default.passwordPrompt(options.prompt, { method: options.type });
        default:
            throw new Error(`unexpected type ${options.type}`);
    }
}
function normal(options, retries = 100) {
    if (retries < 0)
        throw new Error('no input');
    return new Promise((resolve, reject) => {
        process.stdin.setEncoding('utf8');
        process.stderr.write(options.prompt);
        process.stdin.resume();
        process.stdin.once('data', data => {
            process.stdin.pause();
            data = data.trim();
            if (!options.default && options.required && data === '') {
                resolve(normal(options, retries - 1));
            }
            else {
                resolve(data || options.default);
            }
        });
        if (options.timeout) {
            setTimeout(() => reject(new Error('timed out')), options.timeout).unref();
        }
    });
}
